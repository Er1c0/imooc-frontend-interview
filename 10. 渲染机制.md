# 1. 渲染机制

## 1.1. DOCTYPE

- DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或(X)HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。
  解读：DTD 就是告诉浏览器我是什么文档类型，那么浏览器根据这个来判断用什么引擎来解析渲染他。

- DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。
  解读：DOCTYPE 通知浏览器当前文档的 DTD。

- 常见的 DOCTYPE

1. HTML 5
   `!DOCTYPE html`
2. HTML 4.01 Strict，严格模式，该 DTD 包含所有 HTML 元素和属性，但不包括展示型的和弃用的元素（比如 font）
   `<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">`
3. HTML 4.01 Transitional，传统模式（宽松模式），该 DTD 包含所有 HTML 元素和属性，包括展示型的和弃用的元素（比如 font）
   `<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">`

## 1.2. 浏览器渲染过程

**url 解析**：

1. 用户输入 URL 地址

2. 浏览器解析 URL 解析出主机名

3. 浏览器将主机名转换成服务器 ip 地址（浏览器先查找本地 DNS 缓存列表 没有的话 再向浏览器默认的 DNS 服务器发送查询请求 同时缓存）

4. 浏览器将端口号从 URL 中解析出来

5. 浏览器建立一条与目标 Web 服务器的 TCP 连接（三次握手）

6. 浏览器向服务器发送一条 HTTP 请求报文

7. 服务器向浏览器返回一条 HTTP 响应报文

8. 关闭连接 浏览器解析文档

9. 如果文档中有资源 重复 6 7 8 动作 直至资源全部加载完毕

**html 解析**：

![渲染机制](https://user-gold-cdn.xitu.io/2018/6/23/1642d16f798c0875?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 将 HTML 构建成一个 DOM 树（DOM = Document Object Model 文档对象模型），DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
2. 解析 CSS 样式，生成样式结构体
3. 结合 DOM 树和 CSSOM 生成 Rendering Tree（渲染树）。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。
4. 下一步操作称之为布局（Layout），顾名思义就是计算出每个节点在屏幕中的位置 layout render tree。
5. 再下一步就是绘制(Paint)，即遍历 render 树，并使用浏览器 UI 后端层绘制每个节点。

## 1.3. 重排(回流) Reflow

**定义**：DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放到它该出现的位置，这个过程称为 reflow。

**触发 Reflow**：（一般触发 Reflow 时都会需要 Repaint）

1. 当你增加、删除、修改 DOM 节点时；
2. 当你移动 DOM 的位置，或是搞个动画的时候；
3. 当你修改 CSS 样式的时候；（边距、填充、边框、宽高等）
4. 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候；
5. 当你修改网页的默认字体时；在页面加载完后避免这样做，会影响性能

**如何减少 Reflow**：

1. 尽可能限制 reflow 的影响范围。需要改变元素的样式，不要通过父级元素影响子元素。最好直接加在子元素上。
2. 通过设置 style 属性改变结点样式的话，每设置一次都会导致一次 reflow。所以最好通过设置 class 的方式。
3. 减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。
4. 避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。

## 1.4. 重绘 Repaint

**定义**：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 Repaint。（解读：页面要呈现的内容，统统画在屏幕上）

**触发 Repaint**：
1.DOM 改动；
2.CSS 改动； 3.如果有一些不影响布局的样式属性修改(background-color，color，background-image)只会触发重绘，不会触发回流

**如何尽量减少 Repaint 频率**：
将需要追加的多个 DOM 节点先存放在一个片段（createDocumentFragment()）中，最后一次性放到页面中。

## 1.5. 聪明的浏览器

> 但是假设每句 JS 操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。

虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前 flush 队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style 信息的时候，就会让浏览器 flush 队列，比如：

1.offsetTop, offsetLeft, offsetWidth, offsetHeight

2.scrollTop/Left/Width/Height

3.clientTop/Left/Width/Height

4.请求了 getComputedStyle(), 或者 IE 的 currentStyle

所有获取性操作，都会让浏览器提前 flush 队列（提前批处理），浏览器是为了能够让获取性操作获取的样式保证准确性

## 1.6. 渲染优化

都是在想办法减少回流和重绘的次数

1. HTML 文档结构层次尽量少，最好不深于六层；
2. 脚本尽量后放，放在前即可；
3. 少量首屏样式内联放在标签内；
4. 样式结构层次尽量简单；
5. 在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流；
6. 减少通过 JavaScript 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画；
7. position：fixed/absolute；定位的元素的布局属性更改不会影响到其他元素，动画尽量使用在绝对定位或固定定位的元素上；
8. css3 的变换（transform 系列）只是一种视觉效果，只会触发重绘，可以减少一次回流的过程
9. 隐藏在屏幕外，或在页面滚动时，尽量停止动画；
10. 尽量缓存 DOM 查找，查找器尽量简洁；
11. 涉及多域名的网站，可以开启域名预解析
